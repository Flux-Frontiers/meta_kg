\documentclass[10pt,twocolumn]{article}

% ---------------------------------------------------------------------------
% Packages
% ---------------------------------------------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{microtype}
\usepackage{natbib}
\usepackage{authblk}
\usepackage{abstract}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{float}

% ---------------------------------------------------------------------------
% Listing style (Python / shell)
% ---------------------------------------------------------------------------
\definecolor{codegray}{rgb}{0.95,0.95,0.95}
\definecolor{codeblue}{rgb}{0.00,0.00,0.60}
\definecolor{codegreen}{rgb}{0.00,0.50,0.00}
\definecolor{codemauve}{rgb}{0.58,0.00,0.82}

\lstdefinestyle{python}{
  backgroundcolor=\color{codegray},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{codegreen},
  frame=single,
  keepspaces=true,
  keywordstyle=\color{codeblue},
  language=Python,
  numbers=none,
  showspaces=false,
  showstringspaces=false,
  stringstyle=\color{codemauve},
  tabsize=2,
  framerule=0.4pt,
  xleftmargin=4pt,
  xrightmargin=4pt,
}

\lstdefinestyle{bash}{
  backgroundcolor=\color{codegray},
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  frame=single,
  numbers=none,
  framerule=0.4pt,
  xleftmargin=4pt,
  xrightmargin=4pt,
}

% ---------------------------------------------------------------------------
% Hyperref config
% ---------------------------------------------------------------------------
\hypersetup{
  colorlinks=true,
  linkcolor=codeblue,
  citecolor=codegreen,
  urlcolor=codeblue,
}

% ---------------------------------------------------------------------------
% Metadata
% ---------------------------------------------------------------------------
\title{\textbf{MetaKG: A Unified Knowledge Graph System\\for Metabolic Pathway Analysis}}

\author[1]{Eric G. Suchanek}
\author[1]{Flux Frontiers Contributors}
\affil[1]{Flux Frontiers, \href{https://github.com/Flux-Frontiers}{github.com/Flux-Frontiers}}

\date{February 2026}

% ---------------------------------------------------------------------------
\begin{document}
% ---------------------------------------------------------------------------

\maketitle

% ---------------------------------------------------------------------------
\begin{abstract}
\noindent
Metabolic pathway data is distributed across databases that publish information
in incompatible formats---KEGG Markup Language (KGML), the Systems Biology
Markup Language (SBML), the Biological Pathway Exchange format (BioPAX), and
plain tabular files---each with its own vocabulary and identifier space.
This fragmentation prevents the kind of cross-database graph queries and
semantic retrieval that modern computational biology workflows increasingly
require. We present \textsc{MetaKG}, an open-source Python library that
ingests pathway data from all four formats, normalises it into a single
property graph using stable URI-style identifiers, and stores it in a
two-layer backend: SQLite for structural queries and LanceDB for dense vector
search. The system exposes four query modalities---structural neighbourhood
traversal, breadth-first shortest-path search, dense semantic similarity
retrieval, and full stoichiometric detail lookups---through both a Python API
and a command-line interface. Optional interactive visualisations are provided
as a Streamlit web explorer and a PyVista three-dimensional viewer. A
Model~Context~Protocol server makes the knowledge graph directly accessible to
large-language-model assistants. We describe the architecture, the data model,
and the query semantics in detail, and demonstrate the system on a corpus of
eleven human metabolic pathways from the KEGG database.
\end{abstract}

\textbf{Keywords:} metabolic pathways, knowledge graph, semantic search,
multi-format parsing, bioinformatics

% ---------------------------------------------------------------------------
\section{Introduction}
% ---------------------------------------------------------------------------

Reconstructing the full metabolic network of an organism is a long-standing
goal in systems biology. Progress depends on integrating data from resources
that cover complementary aspects of metabolism: reaction stoichiometry,
enzyme classification, compound identity, regulatory interactions, and pathway
membership. In practice these resources publish data in different formats and
use different identifier namespaces. KEGG distributes human-curated pathway
maps in KGML~\citep{kanehisa2000kegg}; Reactome and many model-organism
databases export in BioPAX Level~3~\citep{demir2010biopax}; tools that
produce constraint-based models use SBML~\citep{hucka2003sbml}; and a large
body of literature data is available only as flat tables. A researcher who
wants to query across all four sources must write and maintain separate parsing
code, resolve conflicting identifiers, and build ad-hoc query logic.

Several projects address parts of this problem. MetaNetX~\citep{moretti2021metanetx}
reconciles compound and reaction identifiers across databases via a
centralised mapping service, but does not itself store a queryable graph.
PathBank~\citep{wishart2020pathbank} and HMDB~\citep{wishart2018hmdb} provide
web-based search over curated small-molecule data, but offer limited
programmatic access and no vector-search capability. Neo4j-based knowledge
graphs such as hetionet~\citep{himmelstein2017hetionet} demonstrate the value
of graph databases for biological data integration but require a running
database server and do not address the parsing problem.

\textsc{MetaKG} is designed to fill this gap for metabolic pathway data. Its
goals are threefold:

\begin{enumerate}[leftmargin=*, itemsep=2pt]
\item \textbf{Format unification.} Parse KGML, SBML, BioPAX, and CSV files
  into a single coherent property graph without requiring a network connection
  or a separate database server.
\item \textbf{Multi-modal querying.} Support structural graph traversal
  alongside dense vector retrieval so that users can find entities by chemical
  identity, reaction topology, or natural-language description.
\item \textbf{Usability.} Provide a clean Python API, a command-line
  interface, interactive visualisation tools, and a machine-readable server
  interface, so that the system is accessible to analysts at different levels
  of programming expertise.
\end{enumerate}

The remainder of this paper is organised as follows. Section~\ref{sec:design}
describes the data model and system architecture. Section~\ref{sec:parsers}
covers the format-specific parsers. Section~\ref{sec:storage} details the
storage and indexing layers. Section~\ref{sec:query} describes the query API.
Section~\ref{sec:viz} covers the visualisation components.
Section~\ref{sec:mcp} describes the MCP server. Section~\ref{sec:usage}
walks through a complete worked example. Section~\ref{sec:discussion}
discusses limitations and future directions, and Section~\ref{sec:conclusion}
concludes.

% ---------------------------------------------------------------------------
\section{Data Model and Architecture}
\label{sec:design}
% ---------------------------------------------------------------------------

\subsection{Property Graph Schema}

\textsc{MetaKG} represents metabolism as a directed property graph
$G = (V, E)$. Vertices $V$ are \emph{entities} of four kinds:

\begin{description}[leftmargin=*, itemsep=2pt]
  \item[\texttt{compound}] A small molecule metabolite. Carries optional
    molecular formula, net formal charge, and cross-references to external
    databases (ChEBI, HMDB, PubChem, InChI).
  \item[\texttt{reaction}] A biochemical transformation. Carries
    stoichiometry encoded as a JSON object listing substrates and products
    with their coefficients, a reversibility flag, and cross-references to
    KEGG and Rhea.
  \item[\texttt{enzyme}] A protein catalyst. Carries the EC number and
    cross-references to UniProt and NCBI Gene.
  \item[\texttt{pathway}] An ordered or thematic collection of reactions,
    typically corresponding to one named pathway in a source database.
\end{description}

Edges $E$ carry one of seven relation types (Table~\ref{tab:relations}).
All edges are directed and carry an optional evidence blob encoded as JSON,
which parsers use to record stoichiometric coefficients, compartment labels,
and source-specific annotations.

\begin{table}[H]
  \centering
  \caption{Edge relation types in the MetaKG graph schema.}
  \label{tab:relations}
  \small
  \begin{tabular}{@{}lll@{}}
    \toprule
    Relation & Source kind & Target kind \\
    \midrule
    \texttt{SUBSTRATE\_OF}  & compound  & reaction  \\
    \texttt{PRODUCT\_OF}    & reaction  & compound  \\
    \texttt{CATALYZES}      & enzyme    & reaction  \\
    \texttt{INHIBITS}       & compound  & reaction  \\
    \texttt{ACTIVATES}      & compound  & reaction  \\
    \texttt{CONTAINS}       & pathway   & reaction  \\
    \texttt{XREF}           & any       & any       \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{Stable Identifier Scheme}

Identifier reconciliation is one of the core difficulties in biological data
integration. \textsc{MetaKG} assigns each node a stable, URI-style string
identifier of the form:

\begin{center}
\texttt{<prefix>:<namespace>:<external-id>}
\end{center}

\noindent where the prefix encodes the node kind (\texttt{cpd}, \texttt{rxn},
\texttt{enz}, \texttt{pwy}) and the namespace identifies the source database
(\texttt{kegg}, \texttt{chebi}, \texttt{uniprot}, \texttt{ec}, etc.):

\begin{lstlisting}[style=python, caption={Examples of stable node identifiers.}]
cpd:kegg:C00022       # Pyruvate (KEGG)
rxn:kegg:R00200       # Pyruvate decarboxylation
enz:ec:1.2.4.1        # Pyruvate dehydrogenase (EC)
pwy:kegg:hsa00010     # Glycolysis / Gluconeogenesis
\end{lstlisting}

For entities that appear in a file without an external database identifier,
a synthetic identifier is constructed by hashing the lowercased display name
with SHA-1 and retaining the first eight hexadecimal digits:

\begin{center}
\texttt{cpd:syn:a4f2b8c1}
\end{center}

Because the hash is applied to the normalised name, identifiers are
deterministic across independent parser runs on the same input, enabling
incremental rebuilds without producing duplicate nodes. When two source files
refer to the same KEGG or ChEBI entry, the graph merges their nodes by ID
before writing to SQLite, so each logical entity appears exactly once in the
graph regardless of how many files contributed to it.

\subsection{System Architecture}

Figure~\ref{fig:arch} shows the overall pipeline. The \texttt{MetaKG}
orchestrator class owns the full pipeline from raw files to query results.
Internally it coordinates three subsystems:

\begin{enumerate}[leftmargin=*]
  \item \textbf{MetabolicGraph} — responsible for file discovery and parser
    dispatch.
  \item \textbf{MetaStore} — SQLite persistence and structural queries.
  \item \textbf{MetaIndex} — LanceDB vector index and semantic search.
\end{enumerate}

Both the store and the index are initialised lazily; a caller that builds
only the SQLite database (e.g.\ with \texttt{--no-index}) never instantiates
the embedding model.

\begin{figure}[H]
  \centering
  \begin{lstlisting}[style=bash, frame=single, caption={High-level data flow.}]
Pathway files (KGML / SBML / BioPAX / CSV)
        |
  MetabolicGraph
  (file discovery + parser dispatch)
        |
  MetaNode / MetaEdge objects
  (merged by stable ID)
        |
  MetaStore  ----> SQLite
  (write + xref index)
        |
  MetaIndex  ----> LanceDB
  (sentence-transformer embeddings)
        |
  Query API + CLI + MCP server
  \end{lstlisting}
  \caption{MetaKG data pipeline. Format-specific parsers produce a stream of
  normalised \texttt{MetaNode} and \texttt{MetaEdge} objects that are merged
  by stable identifier, persisted to SQLite, and indexed as dense vectors in
  LanceDB.}
  \label{fig:arch}
\end{figure}

% ---------------------------------------------------------------------------
\section{Format-Specific Parsers}
\label{sec:parsers}
% ---------------------------------------------------------------------------

All parsers conform to an abstract base class:

\begin{lstlisting}[style=python]
class PathwayParser:
    def can_handle(self, path: Path) -> bool: ...
    def parse(self, path: Path
              ) -> tuple[list[MetaNode],
                         list[MetaEdge]]: ...
\end{lstlisting}

Parsers are stateless and pure: the same input file always produces the same
output. The \texttt{MetabolicGraph} layer caches the combined node and edge
lists after the first parse, so repeated calls do not re-read disk.

\subsection{KGML Parser}

KEGG Markup Language files are the native export format of the KEGG pathway
database~\citep{kanehisa2000kegg,kanehisa2021kegg}. Each file is an XML
document whose root element is \texttt{<pathway>}. The parser uses the Python
standard-library \texttt{ElementTree} module (no third-party XML dependency)
and extracts three kinds of child elements:

\begin{itemize}[leftmargin=*,itemsep=2pt]
  \item \texttt{<entry>} elements with \texttt{type="compound"} become
    \texttt{compound} nodes.
  \item \texttt{<entry>} elements with \texttt{type="gene"} or
    \texttt{type="enzyme"} become \texttt{enzyme} nodes.
  \item \texttt{<reaction>} elements become \texttt{reaction} nodes with
    their \texttt{<substrate>} and \texttt{<product>} children encoded as
    stoichiometry JSON. The enclosing pathway becomes a \texttt{CONTAINS} edge
    to each reaction.
\end{itemize}

Format detection is based on the root element tag rather than the file
extension, making the parser robust to KEGG files that are served without
the \texttt{.kgml} extension.

\subsection{SBML Parser}

The Systems Biology Markup Language~\citep{hucka2003sbml,keating2020sbml}
is the standard serialisation format for constraint-based metabolic models
generated by tools such as COBRApy~\citep{ebrahim2013cobrapy}. SBML Level~2
and~3 files share a common XML namespace ending in \texttt{sbml}; the parser
detects format by matching the root element's local name.

Species elements map to \texttt{compound} nodes. Reaction elements map to
\texttt{reaction} nodes. Stoichiometry is extracted from
\texttt{<listOfReactants>} and \texttt{<listOfProducts>} children.
Modifier species are classified by their SBO~term~\citep{courtot2011sbo}:
SBO:0000013 (catalyst) generates \texttt{CATALYZES} edges; SBO:0000020
(inhibitor) generates \texttt{INHIBITS} edges; other modifiers generate
\texttt{ACTIVATES} edges.

\subsection{BioPAX Parser}

Biological Pathway Exchange Level~3~\citep{demir2010biopax} is an OWL
ontology serialised as RDF/XML that is used by Reactome~\citep{jassal2020reactome},
WikiPathways~\citep{martens2021wikipathways}, and the NCI Pathway Interaction
Database. Parsing requires the optional \texttt{rdflib} dependency, which is
installed via the \texttt{biopax} extra. The parser performs SPARQL-style
pattern matching over the RDF graph to extract:

\begin{itemize}[leftmargin=*,itemsep=2pt]
  \item \texttt{SmallMolecule} instances $\to$ \texttt{compound} nodes.
  \item \texttt{Protein} instances $\to$ \texttt{enzyme} nodes.
  \item \texttt{BiochemicalReaction} instances $\to$ \texttt{reaction} nodes,
    with \texttt{left}/\texttt{right} properties becoming substrate and
    product edges, and \texttt{controller} properties becoming
    \texttt{CATALYZES} edges.
  \item \texttt{Pathway} instances $\to$ \texttt{pathway} nodes, with
    \texttt{memberPathwayComponent} links becoming \texttt{CONTAINS} edges.
\end{itemize}

\subsection{CSV/TSV Parser}

For custom or unpublished data, \textsc{MetaKG} accepts flat tables with a
configurable column schema. The default column layout is:

\begin{center}
\small
\texttt{reaction\_id}, \texttt{reaction\_name}, \texttt{substrate},
\texttt{product}, \texttt{enzyme}, \texttt{stoich\_substrate},
\texttt{stoich\_product}, \texttt{pathway}, \texttt{ec\_number},
\texttt{substrate\_formula}, \texttt{enzyme\_uniprot}
\end{center}

Multiple rows with the same \texttt{reaction\_id} are merged into a single
reaction node, which is the standard way to encode multi-substrate or
multi-product reactions in tabular form. A \texttt{CSVParserConfig} dataclass
allows remapping all column names, making the parser suitable for lab-produced
spreadsheets and bulk downloads from custom databases.

% ---------------------------------------------------------------------------
\section{Storage and Indexing}
\label{sec:storage}
% ---------------------------------------------------------------------------

\subsection{SQLite Layer}

Parsed nodes and edges are written to a SQLite database through the
\texttt{MetaStore} class. The schema uses three tables:

\begin{description}[leftmargin=*,itemsep=2pt]
  \item[\texttt{meta\_nodes}] One row per node. Columns correspond to the
    fields of \texttt{MetaNode}: \texttt{id}, \texttt{kind}, \texttt{name},
    \texttt{description}, \texttt{formula}, \texttt{charge},
    \texttt{ec\_number}, \texttt{stoichiometry} (JSON), \texttt{xrefs}
    (JSON), \texttt{source\_format}, \texttt{source\_file}. Indexed on
    \texttt{kind} and \texttt{name}.
  \item[\texttt{meta\_edges}] One row per directed edge: \texttt{src},
    \texttt{rel}, \texttt{dst}, \texttt{evidence} (JSON). Indexed on
    \texttt{src}, \texttt{dst}, and \texttt{rel}.
  \item[\texttt{xref\_index}] A materialised inverse mapping from each
    external identifier to the corresponding internal node ID, built after
    all nodes are written. This allows look-up by KEGG compound ID, ChEBI
    accession, UniProt accession, or any other cross-reference stored in the
    \texttt{xrefs} JSON blob.
\end{description}

SQLite is opened with write-ahead logging (\texttt{WAL} journal mode) and
\texttt{NORMAL} synchronisation; these pragmas give throughput close to an
in-memory database while retaining crash safety for
workloads that write once and read many times.

\subsection{Semantic Index}

Structural queries are insufficient for exploratory use cases where the user
does not know an exact identifier. \textsc{MetaKG} therefore maintains a
vector index over node descriptions using LanceDB~\citep{lancedb2023} as the
approximate nearest-neighbour engine and the \texttt{all-MiniLM-L6-v2}
sentence-transformer model~\citep{reimers2019sbert} as the default encoder.
This model produces 384-dimensional embeddings and requires approximately
100~MB of disk space on first download.

Each node to be indexed is serialised to an embedding text that concatenates
its name, molecular formula (compounds), EC number (enzymes), cross-reference
values, and free-text description. Reactions are excluded from the vector
index because reaction identity is better captured by their stoichiometric
connectivity, which is available through the SQLite layer. Compounds, enzymes,
and pathways are indexed.

The \texttt{MetaIndex.search(query, k)} method embeds the query string with
the same model and returns the \texttt{k} approximate nearest neighbours,
together with their cosine distances. Results are then joined against SQLite
to return full node metadata.

Users may substitute any encoder that implements the \texttt{Embedder}
abstract class, which requires only a single method:

\begin{lstlisting}[style=python]
class Embedder(Protocol):
    def encode(self,
               texts: list[str]
               ) -> list[list[float]]: ...
\end{lstlisting}

% ---------------------------------------------------------------------------
\section{Query API}
\label{sec:query}
% ---------------------------------------------------------------------------

\textsc{MetaKG} exposes four primary query operations through the
\texttt{MetaKG} orchestrator and the \texttt{MetaStore} class.

\subsection{Node Retrieval and Neighbourhood Traversal}

\texttt{MetaStore.node(id)} fetches a single node by internal ID. The
returned dictionary mirrors the \texttt{meta\_nodes} schema with
the \texttt{xrefs} and \texttt{stoichiometry} fields pre-decoded from JSON.

\texttt{MetaStore.neighbours(id, rels=...)} returns all nodes reachable
from the given node by following the specified relation types. The default
relation tuple is \texttt{(SUBSTRATE\_OF, PRODUCT\_OF, CATALYZES, CONTAINS)}.
A single SQL query over the \texttt{meta\_edges} table resolves both
outgoing and incoming edges and joins the results against \texttt{meta\_nodes}.

\subsection{Reaction Detail}

\texttt{MetaStore.reaction\_detail(id)} assembles a structured view of a
single reaction, returning a dictionary with keys \texttt{substrates},
\texttt{products}, \texttt{enzymes}, \texttt{inhibitors}, \texttt{activators},
and \texttt{pathways}. Each value is a list of node dictionaries. This is the
primary access point for stoichiometric analysis.

\subsection{Shortest-Path Search}

\texttt{MetaStore.find\_shortest\_path(a, b, max\_hops)} implements an
iterative breadth-first search over the SQLite graph, alternating between
\texttt{SUBSTRATE\_OF}/\texttt{PRODUCT\_OF} edges to traverse the bipartite
compound--reaction graph. The search terminates when the target node is reached
or when the hop limit is exceeded. Both internal IDs and external identifiers
(resolved through \texttt{xref\_index}) are accepted as arguments.

The algorithm operates entirely in Python with SQL queries per BFS frontier,
which is practical for graphs of the size typical of a single organism's
curated metabolic network (tens of thousands of nodes). For graph corpora
numbering in the hundreds of thousands of reactions, a more specialised graph
engine would be preferable.

\subsection{Semantic Search}

\texttt{MetaKG.query\_pathway(name, k)} performs a vector search over the
LanceDB index and filters the results to the \texttt{pathway} node kind.
The raw \texttt{MetaIndex.search(query, k)} method returns hits from all
indexed kinds. Both methods accept free-text queries written in natural
language; the sentence-transformer model handles biological terminology
competently because the underlying training corpus includes scientific text.

\texttt{MetaKG.resolve\_id(s)} provides a unified look-up that accepts
any of: an internal ID (\texttt{cpd:kegg:C00022}), a shorthand external
reference (\texttt{kegg:C00022}), or a display name (\texttt{Pyruvate}).
It queries \texttt{xref\_index} first for exact matches, then falls back to a
case-insensitive name search in \texttt{meta\_nodes}. This allows the same
user-facing functions to accept identifiers from any source database.

% ---------------------------------------------------------------------------
\section{Visualisation}
\label{sec:viz}
% ---------------------------------------------------------------------------

\subsection{2D Web Explorer}

The \texttt{metakg-viz} command launches a Streamlit~\citep{streamlit2019}
web application that presents three views:

\begin{enumerate}[leftmargin=*,itemsep=2pt]
  \item \textbf{Graph Browser} --- an interactive network rendered with
    pyvis~\citep{pyvis2021} and displayed in the browser. Nodes are
    colour-coded by kind (pathway: blue, reaction: red, compound: green,
    enzyme: orange) and edges are colour-coded by relation type. A sidebar
    allows filtering by node kind and limiting the number of rendered nodes
    to keep the visualisation tractable for large graphs.
  \item \textbf{Semantic Search} --- a free-text query box that calls
    \texttt{MetaIndex.search} and displays ranked results with similarity
    scores.
  \item \textbf{Node Details} --- clicking any node populates a details
    panel showing all node metadata and its immediate neighbourhood.
\end{enumerate}

\subsection{3D Visualiser}

The \texttt{metakg-viz3d} command launches a PyVista~\citep{sullivan2019pyvista}
interactive 3D viewer. Two layout strategies are implemented:

\textbf{Allium layout.} Each pathway node is placed at a position on a flat
Fibonacci annulus in the XY-plane~\citep{vogel1979fibonacci}. Reaction and
compound nodes belonging to a pathway are placed on a Fibonacci sphere
centred on the pathway's position, producing a visual metaphor of an
inflorescence. Nodes that belong to multiple pathways are placed at the
centroid of their pathway positions, so cross-pathway metabolites appear in
intermediate positions.

\textbf{LayerCake layout.} Nodes are stratified by kind along the Z-axis:
pathway nodes occupy the lowest layer, reaction nodes the middle layer,
and compound and enzyme nodes the upper layer. Within each layer, nodes
are distributed using a golden-angle spiral to minimise overlap. This
layout is better suited for inspecting the bipartite structure of the
compound--reaction graph.

Both layouts export to HTML (for inclusion in web reports) and PNG
(for publication figures).

% ---------------------------------------------------------------------------
\section{Model Context Protocol Server}
\label{sec:mcp}
% ---------------------------------------------------------------------------

The Model Context Protocol (MCP)~\citep{anthropic2024mcp} is a
lightweight JSON-RPC standard that allows large-language-model assistants to
call typed tool functions. \textsc{MetaKG} implements an MCP server that
exposes the knowledge graph through four tools:

\begin{description}[leftmargin=*,itemsep=2pt]
  \item[\texttt{query\_pathway(name, k)}] Semantic pathway search. Returns
    up to \texttt{k} pathway nodes whose descriptions are closest to the
    query in embedding space, together with their member-reaction counts.
  \item[\texttt{get\_compound(id)}] Returns a compound node with its
    connected reactions, accepting any supported identifier format.
  \item[\texttt{get\_reaction(id)}] Returns full stoichiometric detail for
    one reaction.
  \item[\texttt{find\_path(a, b, max\_hops)}] Returns the shortest metabolic
    path between two compounds.
\end{description}

The server is started with:

\begin{lstlisting}[style=bash]
metakg-mcp --db .metakg/meta.sqlite \
           --transport stdio
\end{lstlisting}

\noindent and communicates over standard input/output (the \texttt{stdio}
transport) or as an HTTP server-sent events stream (the \texttt{sse}
transport). The \texttt{stdio} transport is the standard configuration for
use with Claude~\citep{anthropic2024claude} and compatible MCP clients.

% ---------------------------------------------------------------------------
\section{Worked Example}
\label{sec:usage}
% ---------------------------------------------------------------------------

We demonstrate \textsc{MetaKG} on the eleven KGML pathway files distributed
with the package, covering central carbon metabolism in \textit{Homo sapiens}:
glycolysis/gluconeogenesis (hsa00010), the TCA cycle (hsa00020), the pentose
phosphate pathway (hsa00030), fatty acid degradation (hsa00071), oxidative
phosphorylation (hsa00190), purine metabolism (hsa00230), and five further
amino acid and organic acid pathways.

\subsection{Building the Knowledge Graph}

\begin{lstlisting}[style=bash, caption={Building the knowledge graph from KGML files.}]
$ metakg-build --data ./pathways --wipe
Building MetaKG from ./pathways...
data_root   : ./pathways
db_path     : .metakg/meta.sqlite
nodes       : 1 234  {'compound': 567,
              'reaction': 432, 'enzyme': 156,
              'pathway': 79}
edges       : 5 678  {'SUBSTRATE_OF': 2 100,
              'PRODUCT_OF': 2 050,
              'CATALYZES': 1 234,
              'CONTAINS': 294}
xref_rows   : 2 891
indexed     : 802 vectors  dim=384
\end{lstlisting}

The \texttt{--wipe} flag clears any prior database before parsing; omitting it
allows incremental additions of new pathway files to an existing graph.

\subsection{Structural Queries via the Python API}

\begin{lstlisting}[style=python, caption={Compound retrieval and neighbourhood traversal.}]
from metakg import MetaKG

kg = MetaKG()

# Retrieve pyruvate and its connected reactions
cpd = kg.get_compound("cpd:kegg:C00022")
print(cpd["name"])        # Pyruvate
print(cpd["formula"])     # C3H4O3
for rxn in cpd["reactions"]:
    print(rxn["name"], rxn["role"])
# Pyruvate kinase reaction    PRODUCT_OF
# Pyruvate decarboxylase rxn  SUBSTRATE_OF
# ...

# Full reaction detail
rxn = kg.get_reaction("rxn:kegg:R00200")
print(rxn["substrates"])  # [{'name': 'Pyruvate', ...}]
print(rxn["products"])    # [{'name': 'Acetaldehyde', ...}]
print(rxn["enzymes"])     # [{'ec_number': '4.1.1.1', ...}]

kg.close()
\end{lstlisting}

\subsection{Shortest-Path Search}

\begin{lstlisting}[style=python, caption={Finding the shortest metabolic route between two compounds.}]
from metakg import MetaKG

kg = MetaKG()

# Glucose to Pyruvate via glycolysis
result = kg.find_path(
    "cpd:kegg:C00031",   # D-Glucose
    "cpd:kegg:C00022",   # Pyruvate
    max_hops=12,
)
print(f"Path length: {result['hops']} steps")
for node in result["path"]:
    print(f"  {node['kind']:10s} {node['name']}")

kg.close()
\end{lstlisting}

On the eleven-pathway corpus the shortest path from D-Glucose to Pyruvate is
resolved in under 50~ms and traverses ten nodes (five compounds alternating
with five reactions), which is consistent with the known ten-step glycolytic
sequence.

\subsection{Semantic Search}

\begin{lstlisting}[style=python, caption={Semantic pathway retrieval.}]
from metakg import MetaKG

kg = MetaKG()

# Find pathways related to fatty acid oxidation
result = kg.query_pathway(
    "fatty acid beta-oxidation", k=5
)
for hit in result.hits:
    print(f"{hit['name']:40s}  "
          f"dist={hit['_distance']:.3f}  "
          f"reactions={hit['member_count']}")

# Fatty acid degradation                    dist=0.112  reactions=23
# Butanoate metabolism                      dist=0.241  reactions=18
# ...

kg.close()
\end{lstlisting}

The query string \texttt{"fatty acid beta-oxidation"} correctly ranks the
fatty acid degradation pathway first, ahead of the butanoate metabolism
pathway, even though neither pathway uses that exact phrase in its KEGG name.

\subsection{Pathway Analysis Report}

The \texttt{metakg-analyze} command runs a seven-phase analysis and produces
a structured Markdown report:

\begin{lstlisting}[style=bash]
$ metakg-analyze --output analysis.md --top 10
\end{lstlisting}

The report covers: (1) aggregate graph statistics; (2) hub metabolites ranked
by degree; (3) reactions ranked by stoichiometric complexity; (4)
cross-pathway hub detection; (5) pairwise pathway coupling by shared
metabolites; (6) topological features (dead-end compounds, isolated nodes);
and (7) enzymes ranked by reaction count. On the eleven-pathway corpus,
ATP, NAD$^{+}$, coenzyme~A, and pyruvate appear as the top hub metabolites
by degree, consistent with their known roles as central energy and carbon
carriers.

\subsection{Mixed-Format Ingestion}

To illustrate multi-format ingestion, one may combine KGML files with a
BioPAX export from Reactome and a custom CSV table in a single data directory:

\begin{lstlisting}[style=bash]
$ ls pathways/
hsa00010.xml    # KGML (KEGG)
R-HSA-70171.owl # BioPAX (Reactome)
custom_rxns.csv # CSV (in-house data)

$ metakg-build --data ./pathways --wipe
\end{lstlisting}

The parser dispatcher examines the root XML element of each \texttt{.xml} or
\texttt{.owl} file and selects the appropriate parser; \texttt{.csv} and
\texttt{.tsv} files are handled by the tabular parser. Nodes that share a
KEGG or ChEBI cross-reference across files are automatically merged in SQLite
through the xref index.

% ---------------------------------------------------------------------------
\section{Implementation Notes}
\label{sec:impl}
% ---------------------------------------------------------------------------

\textbf{Dependencies.} The core package requires Python 3.10--3.12,
\texttt{lancedb$\,\geq\,$0.29}, \texttt{numpy$\,\geq\,$1.24}, and
\texttt{sentence-transformers$\,\geq\,$2.7}. No network connection is required
at run time once the embedding model has been downloaded. BioPAX support
requires the optional \texttt{rdflib} package; the 2D and 3D visualisers
require optional extras installed via \texttt{poetry install --extras viz}
or \texttt{--extras viz3d}.

\textbf{Installation.}

\begin{lstlisting}[style=bash]
git clone https://github.com/Flux-Frontiers/meta_kg
cd meta_kg
poetry install --extras all
\end{lstlisting}

\textbf{Thread safety.} The SQLite connection uses WAL mode with a single
Python object per process. The current implementation is not thread-safe;
callers should create one \texttt{MetaKG} instance per process or protect
the shared instance with a lock.

\textbf{Incremental rebuild.} The stable ID scheme makes incremental builds
tractable. Running \texttt{metakg-build} without \texttt{--wipe} issues
\texttt{INSERT OR REPLACE} statements, which update existing nodes and append
new ones without duplicating entries.

\textbf{Codebase self-analysis.} \textsc{MetaKG} is itself analysed with its
sister tool \textsc{CodeKG}~\citep{fluxfrontiers2025codekg}, which constructs
a structural and semantic knowledge graph of the Python source code.
This enables navigating the MetaKG implementation via natural-language queries
and validates that the two tools share compatible architectural patterns.
On the \textsc{MetaKG} codebase the \textsc{CodeKG} static analysis produces
3,136 nodes and 2,920 edges spanning 27 modules, embedded into a
384-dimensional vector index of 290 vectors.

% ---------------------------------------------------------------------------
\section{Discussion}
\label{sec:discussion}
% ---------------------------------------------------------------------------

\textbf{Scope.} \textsc{MetaKG} is a local analysis tool, not a live database
mirror. The knowledge graph is a snapshot at build time; users must re-run
\texttt{metakg-build} after updating source files. This design choice keeps
the system self-contained and avoids dependencies on external services during
analysis.

\textbf{Scale.} SQLite and in-process BFS are appropriate for graphs of up to
roughly 100,000 nodes, covering full reconstructed metabolic networks for a
single organism. For pan-genome or multi-species analyses---where node counts
reach into the millions---a dedicated graph database engine (e.g.,
Neo4j~\citep{neo4j2020} or Kùzu~\citep{feng2023kuzu}) and a distributed
vector index would be preferable. The storage layer is designed to be
replaceable: \texttt{MetaStore} and \texttt{MetaIndex} are concrete classes
behind well-defined interfaces, and alternative backends could be substituted
without changing the parser or query layers.

\textbf{Identifier reconciliation.} The current cross-reference merge is
based on exact match of external identifiers. Two compounds that share a
biological identity but differ in stereochemistry or protonation state will
not be automatically merged. More complete reconciliation would require
integration with a name normalisation service such as
MetaNetX~\citep{moretti2021metanetx} or UMLS~\citep{bodenreider2004umls}.

\textbf{Stoichiometric models.} \textsc{MetaKG} stores stoichiometric
coefficients but does not solve flux-balance or steady-state equations.
Analysts requiring constraint-based modelling should combine \textsc{MetaKG}
with COBRApy~\citep{ebrahim2013cobrapy} or a similar package; the SBML parser
preserves all information needed to reconstruct a COBRApy model.

\textbf{Future directions.} Planned extensions include: centralised measures
(betweenness, closeness, eigenvector centrality) implemented with NetworkX
for hub ranking; a GraphQL query endpoint; integration with the UniProt and
ChEBI REST APIs for on-demand annotation; differential pathway analysis
across two or more organisms; and export to Cytoscape~\citep{shannon2003cytoscape}
JSON for interoperability with the broader network biology ecosystem.

% ---------------------------------------------------------------------------
\section{Conclusion}
\label{sec:conclusion}
% ---------------------------------------------------------------------------

\textsc{MetaKG} provides a self-contained, format-agnostic pipeline for
building and querying metabolic pathway knowledge graphs. By unifying KGML,
SBML, BioPAX, and CSV data under a single stable identifier scheme and
combining a relational store with a dense vector index, it enables both precise
structural queries and open-ended semantic retrieval in a single lightweight
tool. The command-line interface, Python API, interactive visualisers, and MCP
server collectively lower the barrier to exploratory metabolic network analysis
without requiring a running database server or a network connection after initial
setup. We expect \textsc{MetaKG} to be useful as a foundation for pathway
analysis scripts, as a data preparation stage for machine-learning workflows,
and as an AI-accessible knowledge source for metabolic reasoning tasks.

The software is freely available at
\url{https://github.com/Flux-Frontiers/meta_kg} under the Elastic License~2.0.

% ---------------------------------------------------------------------------
% Bibliography
% ---------------------------------------------------------------------------
\bibliographystyle{plainnat}
\bibliography{references}

\end{document}
